using System;
using System.Diagnostics;
using System.IO;
using System.Linq;

namespace Moriarty.Msrc
{
    internal static class CVE_2023_36664
    {
        private const string Id = "CVE-2023-36664";
        private static readonly string[] Exploits = new[]
        {
            "https://github.com/jakabakos/CVE-2023-36664-Ghostscript-command-injection"
        };

        public static Vulnerability GetVulnerability()
        {
            return new Vulnerability(Id, Exploits);
        }

        private static readonly string[] FilesToCheck = new[]
        {
            "gswin32c.exe", "gswin64c.exe",
            "gswin32.exe", "gswin64.exe",
            "gsdll32.dll", "gsdll64.dll"
        };

        public static void Check(VulnerabilityCollection vulnerabilities)
        {
            var allDrives = DriveInfo.GetDrives().Where(drive => drive.DriveType != DriveType.Network && drive.IsReady);
            bool vulnerableFileFound = false;

            foreach (var drive in allDrives)
            {
                DebugUtility.DebugPrint($"Searching in {drive.Name}...");

                try
                {
                    var foundFiles = Directory.GetFiles(drive.Name, "*", SearchOption.AllDirectories)
                        .Where(file => FilesToCheck.Any(f => file.EndsWith(f, StringComparison.OrdinalIgnoreCase)))
                        .Select(file => new FileInfo(file));

                    foreach (var fileInfo in foundFiles)
                    {
                        var versionInfo = FileVersionInfo.GetVersionInfo(fileInfo.FullName);
                        DebugUtility.DebugPrint($"{fileInfo.FullName} (Version: {versionInfo.FileVersion})");

                        // Set the flag to true if a vulnerable file is found
                        vulnerableFileFound = true;
                    }
                }
                catch (UnauthorizedAccessException)
                {
                    DebugUtility.DebugPrint($"Access denied to {drive.Name}"); 
                }
                catch (IOException)
                {
                    DebugUtility.DebugPrint($"IO error occurred on {drive.Name}");
                }
            }

            if (vulnerableFileFound)
            {
                vulnerabilities.SetAsVulnerable(Id);
            }
        }
    }
}
